<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8" /><title>Random Section Hardcore Loop</title></head>
<body>
<button id="startBtn">▶️ Start</button>
<button id="stopBtn">⏸️ Stop</button>
<pre id="noteDisplay" style="background:#222;color:#eee;padding:10px;height:300px;overflow-y:auto;"></pre>

<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
<script>
  Tone.Transport.bpm.value = 220;
  Tone.Transport.timeSignature = [4, 4];

  // Note utils (same as before)
  const minorPentatonicRoots = ["A", "C", "D", "E", "G"];
  const noteToMidi = { A: 57, C: 60, D: 62, E: 64, G: 67 };
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    return notes[midi % 12] + (Math.floor(midi / 12) - 1);
  }
  function powerChord(root) {
    const rootMidi = noteToMidi[root];
    const fifthMidi = rootMidi + 7;
    return [midiToNoteName(rootMidi), midiToNoteName(fifthMidi)];
  }

  // Synths setup (same as before)
  const guitar = new Tone.PolySynth(Tone.MonoSynth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
  }).chain(new Tone.Distortion(0.8), new Tone.Gain(0.7), Tone.Destination);

  const bass = new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    filter: { type: "lowpass", frequency: 150 },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.3 },
    volume: -8
  }).toDestination();

  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.01,
    octaves: 10,
    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
    volume: 10
  }).toDestination();

  const snare = new Tone.NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 0.001, decay: 0.12, sustain: 0 },
    volume: 5
  }).toDestination();

  const hiHatClosed = new Tone.MetalSynth({
    frequency: 8000,
    envelope: { attack: 0.001, decay: 0.03, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000,
    octaves: 1.5,
    volume: -10
  }).toDestination();

  // Constants
  const measuresPerSection = 4;
  const beatsPerMeasure = 4;
  const sixteenthNotesPerMeasure = 16;
  const stepsPerSection = measuresPerSection * sixteenthNotesPerMeasure; // 64

  // Generate drum pattern (simple variations)
  function generateDrumsPattern(type) {
    // different patterns per type A, B, C, D
    const pattern = [];
    for(let i=0; i<stepsPerSection; i++) {
      let kickHit=false, snareHit=false, hiHatHit=true;
      if(type === "A") {
        kickHit = (i % 4 === 0);
        snareHit = (i % 16 === 8);
      } else if(type === "B") {
        kickHit = (i % 8 === 0);
        snareHit = (i % 16 === 12);
      } else if(type === "C") {
        kickHit = (i % 4 === 0 || i % 4 === 2);
        snareHit = (i % 16 === 4 || i % 16 === 12);
      } else { // D or default
        kickHit = (i % 3 === 0);
        snareHit = (i % 16 === 10);
      }
      pattern.push({ kick: kickHit, snare: snareHit, hiHat: hiHatHit });
    }
    return pattern;
  }

  // Generate guitar phrase (chord per quarter note)
  function generateGuitarPhrase(type) {
    const phrase = [];
    for(let i=0; i<measuresPerSection*beatsPerMeasure; i++) {
      if(type === "A") {
        phrase.push(minorPentatonicRoots[i % minorPentatonicRoots.length]);
      } else if(type === "B") {
        phrase.push(minorPentatonicRoots[(i + 2) % minorPentatonicRoots.length]);
      } else if(type === "C") {
        phrase.push(minorPentatonicRoots[(i + 4) % minorPentatonicRoots.length]);
      } else {
        phrase.push(minorPentatonicRoots[(i + 1) % minorPentatonicRoots.length]);
      }
    }
    return phrase;
  }

  // Generate bass phrase harmonizing guitar phrase
  function generateBassPhrase(guitarPhrase) {
    const phrase = [];
    for(let i=0; i<guitarPhrase.length; i++) {
      const root = guitarPhrase[i];
      if(!root) {
        phrase.push(null);
      } else {
        const rootMidi = noteToMidi[root];
        let midiNote;
        const r = Math.random();
        if(r < 0.6) midiNote = rootMidi - 12;
        else if(r < 0.85) midiNote = rootMidi - 12 + 7;
        else midiNote = rootMidi - 24;
        phrase.push(midiToNoteName(midiNote));
      }
    }
    return phrase;
  }

  // Song sections dictionary
  const sections = {};

  // Pre-generate 4 sections A, B, C, D
  ["A", "B", "C", "D"].forEach(s => {
    const g = generateGuitarPhrase(s);
    const b = generateBassPhrase(g);
    const d = generateDrumsPattern(s);
    sections[s] = { guitar: g, bass: b, drums: d };
  });

  // Common song form patterns
  const formPatterns = [
    ["A","B","A","B"],
    ["A","B","C","D"],
    ["A","A","B","B"],
    ["A","B","C","C"]
  ];

  // Pick random form pattern
  function pickRandomForm() {
    return formPatterns[Math.floor(Math.random() * formPatterns.length)];
  }

  // Display
  const noteDisplay = document.getElementById("noteDisplay");

  // Playback state
  let currentStep = 0;
  let currentSectionIndex = 0;
  let currentForm = [];
  let loop = null;

  async function startLoop() {
    await Tone.start();
    if(loop) return;

    currentForm = pickRandomForm();
    currentSectionIndex = 0;
    currentStep = 0;

    noteDisplay.textContent = `Form pattern: ${currentForm.join(" ")}\n\n`;

    loop = new Tone.Loop((time) => {
      const currentSectionName = currentForm[currentSectionIndex];
      const sec = sections[currentSectionName];
      if (!sec) return;

      // Play instruments at current step
      // Drums on every 16th
      const stepInSection = currentStep % stepsPerSection;
      if(stepInSection % 4 === 0) {
        // Guitar & bass once per quarter note
        const chordIndex = Math.floor(stepInSection / 4);
        const gRoot = sec.guitar[chordIndex];
        const bNote = sec.bass[chordIndex];
        if(gRoot) guitar.triggerAttackRelease(powerChord(gRoot), "8n", time);
        if(bNote) bass.triggerAttackRelease(bNote, "8n", time);
      }
      // Drums every 16th
      const drumStep = sec.drums[stepInSection];
      if(drumStep.kick) kick.triggerAttackRelease("C2", "16n", time);
      if(drumStep.snare) snare.triggerAttackRelease("16n", time + 0.001);
      if(drumStep.hiHat) hiHatClosed.triggerAttackRelease("32n", time + 0.001);

      currentStep++;
      if(currentStep >= stepsPerSection) {
        currentStep = 0;
        currentSectionIndex++;
        if(currentSectionIndex >= currentForm.length) {
          // pick a new random form for endless variation
          currentForm = pickRandomForm();
          noteDisplay.textContent += `\nNew form pattern: ${currentForm.join(" ")}\n\n`;
          currentSectionIndex = 0;
        }
      }
    }, "16n");

    Tone.Transport.start();
    loop.start(0);
  }

  function stopLoop() {
    if(loop) {
      loop.stop();
      loop.cancel();
      loop = null;
    }
    Tone.Transport.stop();
    noteDisplay.textContent = "";
  }

  document.getElementById("startBtn").onclick = startLoop;
  document.getElementById("stopBtn").onclick = stopLoop;
</script>
</body>
</html>
