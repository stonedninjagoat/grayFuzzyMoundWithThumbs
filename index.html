<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8" /><title>Endless Hardcore Punk Jam</title></head>
<body>
<button id="startBtn">▶️ Start</button>
<button id="stopBtn">⏸️ Stop</button>
<pre id="noteDisplay" style="background:#222;color:#eee;padding:10px;height:300px;overflow-y:auto;"></pre>

<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
<script>
  // Set hardcore punk tempo
  Tone.Transport.bpm.value = 220;
  Tone.Transport.timeSignature = [4, 4];

  // Utility to convert MIDI to note name
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    return notes[midi % 12] + (Math.floor(midi / 12) - 1);
  }

  // Basic power chord builder from root note string
  const noteToMidi = { A: 57, C: 60, D: 62, E: 64, G: 67 };
  function powerChord(root) {
    const rootMidi = noteToMidi[root];
    const fifthMidi = rootMidi + 7;
    return [midiToNoteName(rootMidi), midiToNoteName(fifthMidi)];
  }

  // Minor pentatonic roots for riffing
  const minorPentatonicRoots = ["A", "C", "D", "E", "G"];

  // Create instruments
  const guitar = new Tone.PolySynth(Tone.MonoSynth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
  }).chain(new Tone.Distortion(0.8), new Tone.Gain(0.7), Tone.Destination);

  const bass = new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    filter: { type: "lowpass", frequency: 150 },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.3 },
    volume: -8
  }).toDestination();

  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.01,
    octaves: 10,
    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
    volume: 10
  }).toDestination();

  const snare = new Tone.NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 0.001, decay: 0.12, sustain: 0 },
    volume: 5
  }).toDestination();

  const hiHatClosed = new Tone.MetalSynth({
    frequency: 8000,
    envelope: { attack: 0.001, decay: 0.03, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000,
    octaves: 1.5,
    volume: -10
  }).toDestination();

  // Constants
  const measuresPerSection = 4;
  const beatsPerMeasure = 4;
  const sixteenthNotesPerMeasure = 16;
  const stepsPerSection = measuresPerSection * sixteenthNotesPerMeasure; // 64

  // Generate drum pattern by section type
  function generateDrumsPattern(type) {
    const pattern = [];
    for(let i=0; i<stepsPerSection; i++) {
      let kickHit = false, snareHit = false, hiHatHit = true;
      if(type === "A") {
        kickHit = (i % 4 === 0);
        snareHit = (i % 16 === 8);
      } else if(type === "B") {
        kickHit = (i % 8 === 0);
        snareHit = (i % 16 === 12);
      } else if(type === "C") {
        kickHit = (i % 4 === 0 || i % 4 === 2);
        snareHit = (i % 16 === 4 || i % 16 === 12);
      } else { // D
        kickHit = (i % 3 === 0);
        snareHit = (i % 16 === 10);
      }
      pattern.push({ kick: kickHit, snare: snareHit, hiHat: hiHatHit });
    }
    return pattern;
  }

  // Generate guitar phrase (one chord per beat)
  function generateGuitarPhrase(type) {
    const phrase = [];
    for(let i=0; i<measuresPerSection * beatsPerMeasure; i++) {
      if(type === "A") phrase.push(minorPentatonicRoots[i % minorPentatonicRoots.length]);
      else if(type === "B") phrase.push(minorPentatonicRoots[(i + 2) % minorPentatonicRoots.length]);
      else if(type === "C") phrase.push(minorPentatonicRoots[(i + 4) % minorPentatonicRoots.length]);
      else phrase.push(minorPentatonicRoots[(i + 1) % minorPentatonicRoots.length]);
    }
    return phrase;
  }

  // Generate bass phrase harmonizing guitar phrase
  function generateBassPhrase(guitarPhrase) {
    const phrase = [];
    for(let i=0; i<guitarPhrase.length; i++) {
      const root = guitarPhrase[i];
      if(!root) phrase.push(null);
      else {
        const rootMidi = noteToMidi[root];
        let midiNote;
        const r = Math.random();
        if(r < 0.6) midiNote = rootMidi - 12;
        else if(r < 0.85) midiNote = rootMidi - 12 + 7;
        else midiNote = rootMidi - 24;
        phrase.push(midiToNoteName(midiNote));
      }
    }
    return phrase;
  }

  // Define sections A, B, C, D
  const sections = {};
  ["A", "B", "C", "D"].forEach(s => {
    const guitarPhrase = generateGuitarPhrase(s);
    const bassPhrase = generateBassPhrase(guitarPhrase);
    const drumsPattern = generateDrumsPattern(s);
    sections[s] = { guitar: guitarPhrase, bass: bassPhrase, drums: drumsPattern };
  });

  // Possible song forms
  const formPatterns = [
    ["A", "B", "A", "B"],
    ["A", "B", "C", "D"],
    ["A", "A", "B", "B"],
    ["A", "B", "C", "C"]
  ];

  function pickRandomForm() {
    return formPatterns[Math.floor(Math.random() * formPatterns.length)];
  }

  // Display element
  const noteDisplay = document.getElementById("noteDisplay");

  // Playback state
  let currentStep = 0;            // 0–63 (16th notes in current section)
  let currentSectionIndex = 0;    // current section in form
  let currentForm = [];
  let loop = null;

  async function startLoop() {
    await Tone.start();
    if(loop) return;  // already playing

    currentForm = pickRandomForm();
    currentSectionIndex = 0;
    currentStep = 0;
    noteDisplay.textContent = `Form pattern: ${currentForm.join(" ")}\n\n`;

    loop = new Tone.Loop(time => {
      const currentSectionName = currentForm[currentSectionIndex];
      const sec = sections[currentSectionName];
      if(!sec) return;

      const stepInSection = currentStep % stepsPerSection;

      // Guitar & bass on quarter notes (every 4 sixteenths)
      if(stepInSection % 4 === 0) {
        const chordIndex = Math.floor(stepInSection / 4);
        const gRoot = sec.guitar[chordIndex];
        const bNote = sec.bass[chordIndex];
        if(gRoot) guitar.triggerAttackRelease(powerChord(gRoot), "8n", time);
        if(bNote) bass.triggerAttackRelease(bNote, "8n", time);
      }

      // Drums every 16th
      const drumStep = sec.drums[stepInSection];
      if(drumStep.kick) kick.triggerAttackRelease("C2", "16n", time);
      if(drumStep.snare) snare.triggerAttackRelease("16n", time + 0.001);
      if(drumStep.hiHat) hiHatClosed.triggerAttackRelease("32n", time + 0.001);

      // Update step
      currentStep++;

      // If reached end of section, move to next
      if(currentStep >= stepsPerSection) {
        currentStep = 0;
        currentSectionIndex++;
        if(currentSectionIndex >= currentForm.length) {
          // When form ends, pick a new form randomly and keep going
          currentForm = pickRandomForm();
          currentSectionIndex = 0;
          noteDisplay.textContent += `\nNew form: ${currentForm.join(" ")}\n\n`;
          // Auto-scroll to bottom
          noteDisplay.scrollTop = noteDisplay.scrollHeight;
        }
      }
    }, "16n");

    Tone.Transport.start();
    loop.start(0);
  }

  function stopLoop() {
    if(loop) {
      loop.stop();
      loop.cancel();
      loop = null;
    }
    Tone.Transport.stop();
    noteDisplay.textContent = "";
  }

  document.getElementById("startBtn").onclick = startLoop;
  document.getElementById("stopBtn").onclick = stopLoop;
</script>
</body>
</html>
