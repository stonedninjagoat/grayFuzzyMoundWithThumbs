<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Post-Hardcore Chord Progression Generator + Vocal Lead</title>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
<style>
  body {
    background: #111;
    color: #eee;
    font-family: monospace, monospace;
    padding: 1rem;
  }
  #log {
    white-space: pre-wrap;
    max-height: 300px;
    overflow-y: auto;
    background: #222;
    padding: 1rem;
    border-radius: 8px;
  }
  button {
    margin-top: 1rem;
    font-size: 1.2rem;
    padding: 0.5rem 1rem;
    background: #4caf50;
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
  }
</style>
</head>
<body>

<h2>Post-Hardcore Chord Progression Generator + Vocal Lead</h2>
<button id="startBtn">Start</button>
<div id="log"></div>

<script>
(async () => {
  // Tone.js instruments setup
  // Guitar: overdrive guitar synth (use pluck + distortion)
  const guitar = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.4 }
  }).toDestination();
  const guitarDistortion = new Tone.Distortion(0.4).toDestination();
  guitar.connect(guitarDistortion);

  // Bass: bass guitar synth
  const bass = new Tone.MonoSynth({
    oscillator: { type: "triangle" },
    filter: { Q: 2, type: "lowpass", rolloff: -24 },
    envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.4 },
    filterEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.8, release: 1.5, baseFrequency: 200, octaves: 2.6 }
  }).toDestination();

  // Drums: basic acoustic drum kit using Tone.MembraneSynth (kick) + Noise synth (snare)
  const kick = new Tone.MembraneSynth().toDestination();
  const snareNoise = new Tone.NoiseSynth({
    noise: { type: 'white' },
    envelope: { attack: 0.001, decay: 0.2, sustain: 0 }
  }).toDestination();
  const hihat = new Tone.MetalSynth({
    frequency: 400,
    envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000,
    octaves: 1.5
  }).toDestination();

  // Vocal lead synth: clean sine-ish voice, simple monophonic
  const vocalLead = new Tone.Synth({
    oscillator: { type: 'sine' },
    envelope: { attack: 0.02, decay: 0.15, sustain: 0.5, release: 0.3 }
  }).toDestination();

  // Tempo hardcore punk ~200 BPM
  Tone.Transport.bpm.value = 200;

  // Chord map (intervals in semitones)
  const chordMap = {
    A: [0, 3, 7, 10],       // Am7
    B: [0, 4, 7, 11],       // Bmaj7
    C: [0, 5, 7],           // Csus4
    D: [0, 7],              // Power chord D5
    E: [0, 3, 7],           // Em
    F: [0, 4, 7],           // F major
    G: [0, 3, 7, 14],       // Gm(add9)
    H: [0, 3, 6]            // D diminished (example)
  };

  // Map letter chords to root notes (key of A minor scale)
  const rootNoteMap = {
    A: 'A3',
    B: 'B3',
    C: 'C4',
    D: 'D4',
    E: 'E4',
    F: 'F4',
    G: 'G4',
    H: 'A3'
  };

  // Singable vocal scale notes (A minor pentatonic for singability)
  const vocalScale = ['A4', 'C5', 'D5', 'E5', 'G5']; // limited range for singability

  // Helpers
  function noteToMidi(note) {
    return Tone.Frequency(note).toMidi();
  }
  function midiToNoteName(midi) {
    return Tone.Frequency(midi, "midi").toNote();
  }

  // Play a chord on guitar
  function playChord(chordLetter, time) {
    const root = rootNoteMap[chordLetter];
    if (!root) return;
    const rootMidi = noteToMidi(root);
    const intervals = chordMap[chordLetter] || [0, 7];
    const notes = intervals.map(i => midiToNoteName(rootMidi + i));
    guitar.triggerAttackRelease(notes, "8n", time);
  }

  // Play bass root + octave
  function playBass(chordLetter, time) {
    const root = rootNoteMap[chordLetter];
    if (!root) return;
    const rootMidi = noteToMidi(root);
    const octaveNote = midiToNoteName(rootMidi + 12);
    bass.triggerAttackRelease([root, octaveNote], "8n", time);
  }

  // Basic drum pattern for 1 bar (4 beats)
  // Kick on 1 & 3, Snare on 2 & 4, HiHat 8th notes
  function scheduleDrums(startTime) {
    for (let i = 0; i < 4; i++) {
      const beatTime = startTime + i * Tone.Time("4n").toSeconds();
      if (i % 2 === 0) {
        kick.triggerAttack(beatTime);
      } else {
        snareNoise.triggerAttack(beatTime);
      }
      // HiHat 8th notes
      hihat.triggerAttack(beatTime);
      hihat.triggerAttack(beatTime + Tone.Time("8n").toSeconds());
    }
  }

  // Section chord progression patterns (varied)
  const patterns = [
    "ABAB",
    "ABCD",
    "ABCC",
    "AABB",
    "ABBA",
    "ACBD",
    "ABGH",
    "EFAH",
  ];

  // Log output for display
  const logDiv = document.getElementById("log");
  function log(text) {
    logDiv.textContent += text + "\n";
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // Generate vocal melody notes for one chord sequence
  // Simple approach: pick vocalScale notes that harmonize with chord root
  // For each chord letter, pick a vocal note that fits chord tone or scale tone
  function generateVocalMelody(chordSequence) {
    const melody = [];
    for (const chordLetter of chordSequence) {
      const rootMidi = noteToMidi(rootNoteMap[chordLetter]);
      // Try to pick vocal note near root + 12 semitones (1 octave higher), but in vocalScale
      // We'll just pick a random note from vocalScale for now, with some weighting to root related note
      const rootNote = rootNoteMap[chordLetter].replace(/\d/, '4'); // use octave 4 for comparison
      // Filter vocalScale notes near chord root within a 5 semitone range for consonance
      const rootMidi4 = noteToMidi(rootNote);
      const candidates = vocalScale.filter(vn => Math.abs(noteToMidi(vn) - rootMidi4) <= 5);
      if (candidates.length === 0) {
        melody.push(vocalScale[0]); // fallback
      } else {
        melody.push(candidates[Math.floor(Math.random() * candidates.length)]);
      }
    }
    return melody;
  }

  // Play one measure of chord sequence and vocal melody
  // Each chord lasts a quarter note (4 chords per measure)
  function playMeasure(chordSequence, measureIndex, startTime) {
    for (let i = 0; i < chordSequence.length; i++) {
      const chordLetter = chordSequence[i];
      const time = startTime + i * Tone.Time("4n").toSeconds();
      playChord(chordLetter, time);
      playBass(chordLetter, time);
    }
    scheduleDrums(startTime);

    // Vocal melody
    const vocalMelody = generateVocalMelody(chordSequence);
    for (let i = 0; i < vocalMelody.length; i++) {
      const vocalTime = startTime + i * Tone.Time("4n").toSeconds() + 0.05; // slight delay to sit on top
      vocalLead.triggerAttackRelease(vocalMelody[i], "8n", vocalTime);
    }
  }

  // Play indefinitely by randomly selecting patterns
  let currentMeasure = 0;

  function scheduleNext() {
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
    const now = Tone.now() + 0.1; // small delay
    log(`Measure ${currentMeasure + 1}: Pattern ${pattern}`);

    playMeasure(pattern, currentMeasure, now);

    currentMeasure++;
    // Schedule next measure after 1 bar (4 quarter notes)
    Tone.Transport.scheduleOnce(scheduleNext, now + Tone.Time("1m").toSeconds());
  }

  // Start/stop handling
  const startBtn = document.getElementById("startBtn");
  let started = false;

  startBtn.onclick = async () => {
    if (!started) {
      await Tone.start();
      log("Audio started! Playing...");
      Tone.Transport.start();
      scheduleNext();
      startBtn.textContent = "Stop";
      started = true;
    } else {
      Tone.Transport.stop();
      Tone.Transport.cancel();
      log("Stopped.");
      startBtn.textContent = "Start";
      started = false;
      currentMeasure = 0;
    }
  };

})();
</script>

</body>
</html>
