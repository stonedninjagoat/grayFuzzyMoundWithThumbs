<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hardcore Punk Generator - Phrase Patterns</title>
<style>
  body {
    font-family: monospace;
    background: black;
    color: lime;
    text-align: center;
    padding: 20px;
  }
  button {
    font-size: 18px;
    margin: 10px;
    padding: 10px 20px;
    cursor: pointer;
  }
  #noteDisplay {
    max-width: 700px;
    margin: 20px auto;
    background: #111;
    border: 1px solid lime;
    padding: 10px;
    white-space: pre-wrap;
    height: 300px;
    overflow-y: auto;
    text-align: left;
  }
</style>
</head>
<body>

<h1>⚡ Hardcore Punk Generator — Patterned Phrases ⚡</h1>
<button id="startBtn">▶️ Start</button>
<button id="stopBtn">⏸️ Stop</button>

<div id="noteDisplay">Press Start to play...</div>

<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
<script>
  // === Setup Instruments ===

  const powerChords = {
    "C": ["C4", "G4"],
    "D": ["D4", "A4"],
    "E": ["E4", "B4"],
    "F": ["F4", "C5"],
    "G": ["G3", "D4"],
    "A": ["A3", "E4"],
    "B": ["B3", "F#4"]
  };
  const roots = Object.keys(powerChords);

  const guitar = new Tone.PolySynth(Tone.MonoSynth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.005, decay: 0.2, sustain: 0.1, release: 0.2 }
  }).chain(new Tone.Distortion(0.7), Tone.Destination);

  const bass = new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    filter: { type: "lowpass", frequency: 120 },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.3 }
  }).toDestination();

  const drums = new Tone.Sampler({
    urls: {
      "C1": "kick.mp3",
      "D1": "snare.mp3",
      "E1": "hihat.mp3"
    },
    baseUrl: "https://tonejs.github.io/audio/drum-samples/CR78/",
  }).toDestination();

  // === Musical params ===
  const beatsPerMeasure = 4;
  const measuresPerPhrase = 4;
  const stepsPerPhrase = beatsPerMeasure * measuresPerPhrase; // 16 steps per phrase, quarter note resolution

  // Patterns to choose from:
  // Letters correspond to unique phrases (A, B, C, D, etc.)
  const patterns = [
    "ABAB",
    "AABB",
    "AAAABBBB",
    "AABBCCDD",
    "ABCD",
    "AABBCCCC",
    "AAAABBCC",
    "AABBBBCCDD",
    "AB",
    "ABCC"
  ];

  // Store generated phrases here (max 4 phrases: A-D)
  // Each phrase is an array of 16 step objects: {guitar: chordRoot, bass: rootNote, drums: [kick, snare, hihat]}
  let phrases = {};

  // Create a phrase with random music
  function generatePhrase() {
    const phrase = [];
    for (let step = 0; step < stepsPerPhrase; step++) {
      // Random guitar chord root or rest (20% rest)
      const guitarRoot = Math.random() < 0.8 ? roots[Math.floor(Math.random() * roots.length)] : null;
      // Bass follows guitar root or is rest (20% rest)
      const bassNote = guitarRoot ? guitarRoot + "2" : null;

      // Drums: kick on beat 1 & 3, snare on 2 & 4, hihat constant eighths
      // Since quarter note steps, approximate pattern:
      const beatInMeasure = step % beatsPerMeasure;
      const drumsStep = {
        kick: beatInMeasure === 0 || beatInMeasure === 2,
        snare: beatInMeasure === 1 || beatInMeasure === 3,
        hihat: true
      };

      phrase.push({
        guitar: guitarRoot,
        bass: bassNote,
        drums: drumsStep
      });
    }
    return phrase;
  }

  // Generate up to 4 unique phrases (A-D)
  function generatePhrases(numPhrases) {
    phrases = {};
    const letters = ["A", "B", "C", "D"];
    for (let i = 0; i < numPhrases; i++) {
      phrases[letters[i]] = generatePhrase();
    }
  }

  // Utility to play a phrase starting at given Transport time
  function playPhrase(phrase, startTime) {
    for (let step = 0; step < phrase.length; step++) {
      const stepData = phrase[step];
      const time = startTime + step * Tone.Time("4n").toSeconds();

      // Guitar play power chord
      if (stepData.guitar) {
        const chord = powerChords[stepData.guitar];
        guitar.triggerAttackRelease(chord, "8n", time);
      }

      // Bass play root note
      if (stepData.bass) {
        bass.triggerAttackRelease(stepData.bass, "8n", time);
      }

      // Drums
      if (stepData.drums.kick) drums.triggerAttackRelease("C1", "16n", time);
      if (stepData.drums.snare) drums.triggerAttackRelease("D1", "16n", time + 0.05);
      if (stepData.drums.hihat) drums.triggerAttackRelease("E1", "16n", time + 0.1);
    }
  }

  // Text representation helper
  function phraseToText(phrase) {
    let lines = {guitar: "", bass: "", drums: ""};
    for (const step of phrase) {
      lines.guitar += step.guitar ? step.guitar : "-";
      lines.bass += step.bass ? step.bass[0] : "-";
      // Drums: K for kick, S for snare, H for hihat (always on)
      let d = "";
      if (step.drums.kick) d += "K";
      if (step.drums.snare) d += "S";
      if (step.drums.hihat) d += "H";
      lines.drums += d.padEnd(3, " ");
    }
    return lines;
  }

  // === Playback control ===
  let isPlaying = false;

  const noteDisplay = document.getElementById("noteDisplay");

  async function startPlayback() {
    if (Tone.context.state !== "running") {
      await Tone.start();
      console.log("Audio context started");
    }

    isPlaying = true;
    noteDisplay.textContent = "Generating phrases...\n";

    // Choose pattern randomly
    const pattern = patterns[Math.floor(Math.random() * patterns.length)];
    noteDisplay.textContent += `Pattern chosen: ${pattern}\n`;

    // Determine number of unique phrases needed from pattern
    const uniqueLetters = [...new Set(pattern.split(''))];
    generatePhrases(uniqueLetters.length);

    // Show phrase text for debugging
    for (const letter of uniqueLetters) {
      const p = phrases[letter];
      const text = phraseToText(p);
      noteDisplay.textContent += `\nPhrase ${letter}:\nGuitar: ${text.guitar}\nBass:   ${text.bass}\nDrums:  ${text.drums}\n`;
    }

    // Schedule playback via Tone.Transport
    Tone.Transport.bpm.value = 200; // Hardcore punk fast tempo
    Tone.Transport.seconds = 0;
    Tone.Transport.cancel();

    let currentMeasure = 0;
    const measuresPerPhrase = 4;
    const secondsPerMeasure = Tone.Time("1m").toSeconds() / 4; // 4/4 time, so 1 measure = 1m/4

    // Compose playback sequence from pattern
    // Each letter = 4 measures; repeat each letter twice in a row
    const playbackSequence = [];
    for (const letter of pattern) {
      playbackSequence.push(letter);
      playbackSequence.push(letter);
    }

    for (let i = 0; i < playbackSequence.length; i++) {
      const phraseLetter = playbackSequence[i];
      const startTime = i * measuresPerPhrase * secondsPerMeasure;
      playPhrase(phrases[phraseLetter], startTime);
    }

    Tone.Transport.start();

    // Update display during playback (roughly)
    let phraseIndex = 0;
    function updateDisplay() {
      if (!isPlaying) return;
      noteDisplay.textContent += `\nPlaying phrase ${playbackSequence[phraseIndex]} (${phraseIndex + 1}/${playbackSequence.length})`;
      phraseIndex++;
      if (phraseIndex >= playbackSequence.length) {
        noteDisplay.textContent += "\nPlayback ended.";
        isPlaying = false;
        Tone.Transport.stop();
        return;
      }
      setTimeout(updateDisplay, measuresPerPhrase * 1000 * (60 / Tone.Transport.bpm.value));
    }
    updateDisplay();
  }

  function stopPlayback() {
    isPlaying = false;
    Tone.Transport.stop();
    noteDisplay.textContent += "\nStopped by user.";
  }

  // UI event handlers
  document.getElementById("startBtn").onclick = () => {
    if (!isPlaying) startPlayback();
  };
  document.getElementById("stopBtn").onclick = () => {
    if (isPlaying) stopPlayback();
  };
</script>

</body>
</html>
