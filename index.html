<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Post-Hardcore Jam - Full Working Version</title>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; background: #111; color: #eee; }
  button { font-size: 1.2em; padding: 10px 20px; cursor: pointer; }
</style>
</head>
<body>
<h1>Post-Hardcore Jam - Guitar, Bass, Drums & Vocals</h1>
<button id="startButton">Start Jam</button>
<p>Make sure your speakers are on! üé∏ü•Åüé§</p>

<script>
  const startButton = document.getElementById('startButton');

  // Instrument setup

  // Guitar synth with distortion (overdrive)
  const guitarSynth = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "sawtooth" },
    envelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.6 }
  });
  const distortion = new Tone.Distortion(0.7).toDestination();
  guitarSynth.connect(distortion);

  // Bass synth - mono with filter
  const bassSynth = new Tone.MonoSynth({
    oscillator: { type: "square" },
    filter: { Q: 2, type: "lowpass", rolloff: -24 },
    envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.8 },
    filterEnvelope: { attack: 0.001, decay: 0.01, sustain: 0.7, release: 0.8, baseFrequency: 200, octaves: 2.6 }
  }).toDestination();

  // Drums - load samples
  const drumKit = new Tone.Players({
    kick: "https://tonejs.github.io/audio/drum-samples/breakbeat/kick.mp3",
    snare: "https://tonejs.github.io/audio/drum-samples/breakbeat/snare.mp3",
    hihat: "https://tonejs.github.io/audio/drum-samples/breakbeat/hihat.mp3"
  }).toDestination();

  // Vocal lead synth - sine wave with light reverb
  const vocalLead = new Tone.Synth({
    oscillator: { type: "sine" },
    envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.6 }
  });
  const reverb = new Tone.Reverb({ decay: 2, wet: 0.15 }).toDestination();
  vocalLead.connect(reverb);

  // Root notes for chords
  const rootNoteMap = {
    A: "A3",
    B: "B3",
    C: "C4",
    D: "D4",
    E: "E4",
    F: "F4",
    G: "G4"
  };

  // Chord intervals for power chords and triads
  const chordMap = {
    A: [0, 7],            // A5 power chord
    B: [0, 4, 7],         // B major
    C: [0, 3, 7],         // C minor
    D: [0, 4, 7],         // D major
    E: [0, 7],            // E5 power chord
    F: [0, 3, 7],         // F minor
    G: [0, 4, 7]          // G major
  };

  // Different chord progression patterns (4 chords each)
  const progressionPatterns = [
    ['A', 'B', 'A', 'B'],
    ['A', 'A', 'B', 'B'],
    ['A', 'B', 'C', 'D'],
    ['A', 'B', 'C', 'C'],
    ['A', 'B', 'C', 'B'],
    ['A', 'C', 'B', 'D']
  ];

  // Convert note name like "C4" to MIDI number
  function noteToMidi(note) {
    const noteRegex = /^([A-G])(#|b)?(\d)$/;
    const noteBase = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
    const m = note.match(noteRegex);
    if (!m) return null;
    let [_, letter, accidental, octave] = m;
    let midi = noteBase[letter] + 12 * (parseInt(octave) + 1);
    if (accidental === "#") midi += 1;
    else if (accidental === "b") midi -= 1;
    return midi;
  }

  // Convert MIDI number back to note name
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const octave = Math.floor(midi / 12) - 1;
    const note = notes[midi % 12];
    return note + octave;
  }

  // Play chord on guitar
  function playChord(chordLetter, time) {
    const root = rootNoteMap[chordLetter];
    if (!root) return;
    const rootMidi = noteToMidi(root);
    const intervals = chordMap[chordLetter] || [0, 7];
    const notes = intervals.map(i => midiToNoteName(rootMidi + i));
    guitarSynth.triggerAttack(notes, time);
    guitarSynth.triggerRelease(time + Tone.Time("2n").toSeconds()); // half note sustain
  }

  // Play bass root + octave notes
  function playBass(chordLetter, time) {
    const root = rootNoteMap[chordLetter];
    if (!root) return;
    const rootMidi = noteToMidi(root);
    const octaveNote = midiToNoteName(rootMidi + 12);
    bassSynth.triggerAttack([root, octaveNote], time);
    bassSynth.triggerRelease(time + Tone.Time("2n").toSeconds());
  }

  // Schedule punk drums - kick on 1 & 3, snare on 2 & 4, hi-hat every 8th note
  function scheduleDrums(startTime) {
    drumKit.player("kick").start(startTime);
    drumKit.player("kick").start(startTime + Tone.Time("2n").toSeconds());
    drumKit.player("snare").start(startTime + Tone.Time("4n").toSeconds());
    drumKit.player("snare").start(startTime + Tone.Time("4n").toSeconds() * 3);
    for (let i = 0; i < 8; i++) {
      drumKit.player("hihat").start(startTime + i * Tone.Time("8n").toSeconds());
    }
  }

  // Generate simple vocal melody for given chords
  function generateVocalMelody(chords) {
    const scaleNotes = {
      A: ["A4", "C5", "E5"],
      B: ["B4", "D5", "F#5"],
      C: ["C5", "E5", "G5"],
      D: ["D5", "F#5", "A5"],
      E: ["E5", "G#5", "B5"],
      F: ["F5", "A5", "C6"],
      G: ["G4", "B4", "D5"]
    };
    let melody = [];
    for (let c of chords) {
      const choices = scaleNotes[c] || ["C5"];
      melody.push(choices[Math.floor(Math.random() * choices.length)]);
    }
    return melody;
  }

  // Play one measure (4 chords)
  function playMeasure(chordSequence, startTime) {
    for (let i = 0; i < chordSequence.length; i++) {
      const chordLetter = chordSequence[i];
      const time = startTime + i * Tone.Time("4n").toSeconds();
      playChord(chordLetter, time);
      playBass(chordLetter, time);
    }
    scheduleDrums(startTime);

    const vocalMelody = generateVocalMelody(chordSequence);
    for (let i = 0; i < vocalMelody.length; i++) {
      const vocalTime = startTime + i * Tone.Time("4n").toSeconds() + 0.05;
      vocalLead.triggerAttackRelease(vocalMelody[i], "8n", vocalTime);
    }
  }

  // Jam start function
  function startJam() {
    Tone.Transport.bpm.value = 200;
    Tone.Transport.start();

    let currentMeasure = 0;
    let currentPattern = progressionPatterns[0];

    Tone.Transport.scheduleRepeat(time => {
      if (currentMeasure % 4 === 0) {
        currentPattern = progressionPatterns[Math.floor(Math.random() * progressionPatterns.length)];
      }
      playMeasure(currentPattern, time);
      currentMeasure++;
    }, "1m");
  }

  // User must click button to start audio
  startButton.onclick = async () => {
    await Tone.start();
    startJam();
    startButton.disabled = true;
    startButton.innerText = "Playing...";
  };
</script>
</body>
</html>
