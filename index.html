<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hardcore Punk Music Generator - Overdrive Guitar, Bass Guitar, Acoustic Drums</title>
<style>
  body {
    font-family: monospace;
    background: #111;
    color: #eee;
    padding: 20px;
    text-align: center;
  }
  #noteDisplay {
    width: 95%;
    height: 300px;
    margin: 10px auto;
    background: #222;
    border: 1px solid #444;
    padding: 10px;
    overflow-y: scroll;
    white-space: pre-wrap;
    text-align: left;
    font-size: 14px;
  }
  button {
    padding: 10px 20px;
    margin: 10px;
    font-size: 16px;
    cursor: pointer;
  }
</style>
</head>
<body>

<h1>Hardcore Punk Music Generator</h1>
<button id="startBtn">▶️ Start</button>
<button id="stopBtn">⏸️ Stop</button>
<div id="noteDisplay"></div>

<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
<script>
  // Set hardcore punk tempo ~200 bpm
  Tone.Transport.bpm.value = 200;

  // Minor pentatonic scale roots common in punk
  const minorPentatonicRoots = ["A", "C", "D", "E", "G"];

  const noteToMidi = {A: 57, C: 60, D: 62, E: 64, G: 67};
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const note = notes[midi % 12];
    const octave = Math.floor(midi / 12) - 1;
    return note + octave;
  }

  function powerChord(root) {
    const rootMidi = noteToMidi[root];
    const fifthMidi = rootMidi + 7;
    return [midiToNoteName(rootMidi), midiToNoteName(fifthMidi)];
  }

  // --- Guitar: PolySynth with Overdrive Distortion for electric guitar tone
  const guitar = new Tone.PolySynth(Tone.Synth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
  }).chain(
    new Tone.Distortion(0.9),   // Heavy overdrive distortion
    new Tone.Filter(800, "lowpass"), // Smooth filter to tame highs
    new Tone.Gain(0.7),
    Tone.Destination
  );

  // --- Bass: MonoSynth with bass guitar tone
  const bass = new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    filter: { type: "lowpass", frequency: 150, rolloff: -24 },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.3 },
    filterEnvelope: { attack: 0.005, decay: 0.1, sustain: 0.7, release: 0.2, baseFrequency: 100, octaves: 2.6 },
    volume: -6
  }).toDestination();

  // --- Drums: Acoustic drum sampler
  // Samples from https://tonejs.github.io/audio/drum-samples/ (acoustic kit)
  const drums = new Tone.Sampler({
    urls: {
      "C1": "kick.wav",
      "D1": "snare.wav",
      "E1": "hihat-open.wav",
      "F1": "hihat-closed.wav"
    },
    baseUrl: "https://tonejs.github.io/audio/drum-samples/acoustic-kit/",
    volume: 0
  }).toDestination();

  // === Rhythm & phrase settings
  const beatsPerMeasure = 4;
  const measuresPerPhrase = 4;
  const stepsPerPhrase = beatsPerMeasure * measuresPerPhrase; // 16 quarter notes

  // Generate drum pattern (32 eighth notes per phrase)
  function generateDrums() {
    const pattern = [];
    const totalSteps = stepsPerPhrase * 2; // 32 steps (8th notes)

    for (let i = 0; i < totalSteps; i++) {
      const stepInMeasure = Math.floor(i / 2) % beatsPerMeasure;
      const isOnBeat = i % 2 === 0;

      // Kick on 1 and 3 beats (typical punk feel)
      let kick = isOnBeat && (stepInMeasure === 0 || stepInMeasure === 2);

      // Snare on 2 and 4 beats
      let snare = isOnBeat && (stepInMeasure === 1 || stepInMeasure === 3);

      // Hi-hats: closed on every 8th note, open on off-beats occasionally
      let hiHatOpen = !isOnBeat && Math.random() < 0.3;
      let hiHatClosed = !hiHatOpen;

      pattern.push({ kick, snare, hiHatOpen, hiHatClosed });
    }

    return pattern;
  }

  // Guitar phrase (16 quarter notes)
  function generateGuitarPhrase() {
    const phrase = [];
    for (let i = 0; i < stepsPerPhrase; i++) {
      if (Math.random() < 0.85) {
        const root = minorPentatonicRoots[Math.floor(Math.random() * minorPentatonicRoots.length)];
        phrase.push(root);
      } else {
        phrase.push(null);
      }
    }
    return phrase;
  }

  // Bass phrase harmonizes guitar
  function generateBassPhrase(guitarPhrase) {
    const phrase = [];
    for (let i = 0; i < guitarPhrase.length; i++) {
      const root = guitarPhrase[i];
      if (!root) {
        phrase.push(null);
      } else {
        const rootMidi = noteToMidi[root];
        const choice = Math.random();
        let midiNote;
        if (choice < 0.6) midiNote = rootMidi - 12; // octave below root
        else if (choice < 0.8) midiNote = rootMidi - 12 + 7; // fifth below root
        else midiNote = rootMidi - 24; // two octaves below
        phrase.push(midiToNoteName(midiNote));
      }
    }
    return phrase;
  }

  // Display area for notes
  const noteDisplay = document.getElementById("noteDisplay");
  let displayLines = { guitar: "", bass: "", drums: "" };

  function appendPhraseToDisplay(guitarPhrase, bassPhrase, drumsPattern) {
    const measureLength = beatsPerMeasure;
    const phraseMeasures = measuresPerPhrase;

    // Guitar and bass
    for (let i = 0; i < guitarPhrase.length; i++) {
      if (i > 0 && i % measureLength === 0) {
        displayLines.guitar += " | ";
        displayLines.bass += " | ";
      }
      displayLines.guitar += guitarPhrase[i] ? guitarPhrase[i] : "-";
      displayLines.bass += bassPhrase[i] ? bassPhrase[i][0] : "-";
    }

    // Drums pattern: 32 steps (8th notes)
    for (let i = 0; i < drumsPattern.length; i++) {
      if (i > 0 && i % (measureLength * 2) === 0) {
        displayLines.drums += " | ";
      }
      const d = drumsPattern[i];
      let drumChar = "";
      if (d.kick) drumChar += "K";
      if (d.snare) drumChar += "S";
      if (d.hiHatOpen) drumChar += "o";
      else if (d.hiHatClosed) drumChar += "c";
      if (drumChar === "") drumChar = "-";
      displayLines.drums += drumChar.padEnd(3, " ");
    }

    noteDisplay.textContent =
      "Guitar : " + displayLines.guitar + "\n" +
      "Bass   : " + displayLines.bass + "\n" +
      "Drums  : " + displayLines.drums + "\n\n";

    noteDisplay.scrollTop = noteDisplay.scrollHeight;
  }

  // Play drum sounds
  function playDrums(drumPattern, startTime) {
    for (let i = 0; i < drumPattern.length; i++) {
      const time = startTime + i * Tone.Time("8n").toSeconds();
      const d = drumPattern[i];
      if (d.kick) drums.triggerAttackRelease("C1", "16n", time);
      if (d.snare) drums.triggerAttackRelease("D1", "16n", time + 0.02);
      if (d.hiHatOpen) drums.triggerAttackRelease("E1", "16n", time + 0.01);
      else if (d.hiHatClosed) drums.triggerAttackRelease("F1", "16n", time + 0.01);
    }
  }

  // Play guitar phrase
  function playGuitar(guitarPhrase, startTime) {
    for (let i = 0; i < guitarPhrase.length; i++) {
      const time = startTime + i * Tone.Time("4n").toSeconds();
      const root = guitarPhrase[i];
      if (root) guitar.triggerAttackRelease(powerChord(root), "8n", time);
    }
  }

  // Play bass phrase
  function playBass(bassPhrase, startTime) {
    for (let i = 0; i < bassPhrase.length; i++) {
      const time = startTime + i * Tone.Time("4n").toSeconds();
      const note = bassPhrase[i];
      if (note) bass.triggerAttackRelease(note, "8n", time);
    }
  }

  // Schedule phrases on Transport
  const phraseDuration = Tone.Time("1m").toSeconds() * measuresPerPhrase;

  function schedulePhrase(time) {
    const guitarPhrase = generateGuitarPhrase();
    const bassPhrase = generateBassPhrase(guitarPhrase);
    const drumsPattern = generateDrums();

    appendPhraseToDisplay(guitarPhrase, bassPhrase, drumsPattern);

    playGuitar(guitarPhrase, time);
    playBass(bassPhrase, time);
    playDrums(drumsPattern, time);
  }

  document.getElementById("startBtn").onclick = async () => {
    if (Tone.Transport.state !== "started") {
      await Tone.start();
      displayLines = { guitar: "", bass: "", drums: "" };
      noteDisplay.textContent = "";

      Tone.Transport.cancel();
      Tone.Transport.scheduleRepeat((time) => {
        schedulePhrase(time);
      }, phraseDuration);

      Tone.Transport.start();
    }
  };

  document.getElementById("stopBtn").onclick = () => {
    Tone.Transport.stop();
    Tone.Transport.cancel();
  };
</script>

</body>
</html>
