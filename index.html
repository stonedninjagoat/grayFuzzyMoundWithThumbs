<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Continuous Hardcore Punk Generator Fixed</title>
<style>
  body { background: #111; color: #eee; font-family: monospace; padding: 20px; }
  #noteDisplay {
    width: 95%; height: 300px; background: #222; border: 1px solid #444; padding: 10px;
    overflow-y: scroll; white-space: pre-wrap; text-align: left; font-size: 14px;
  }
  button {
    padding: 10px 20px; margin: 10px; font-size: 16px; cursor: pointer;
  }
</style>
</head>
<body>

<h1>Hardcore Punk Generator - Continuous Loop & Drums Fixed</h1>
<button id="startBtn">▶️ Start</button>
<button id="stopBtn">⏸️ Stop</button>
<div id="noteDisplay"></div>

<script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
<script>
  Tone.Transport.bpm.value = 220;
  Tone.Transport.timeSignature = [4, 4];

  // Notes
  const minorPentatonicRoots = ["A", "C", "D", "E", "G"];
  const noteToMidi = { A: 57, C: 60, D: 62, E: 64, G: 67 };
  function midiToNoteName(midi) {
    const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const note = notes[midi % 12];
    const octave = Math.floor(midi / 12) - 1;
    return note + octave;
  }
  function powerChord(root) {
    const rootMidi = noteToMidi[root];
    const fifthMidi = rootMidi + 7;
    return [midiToNoteName(rootMidi), midiToNoteName(fifthMidi)];
  }

  // Synths
  const guitar = new Tone.PolySynth(Tone.MonoSynth, {
    oscillator: { type: "square" },
    envelope: { attack: 0.005, decay: 0.1, sustain: 0.2, release: 0.1 }
  }).chain(new Tone.Distortion(0.8), new Tone.Gain(0.7), Tone.Destination);

  const bass = new Tone.MonoSynth({
    oscillator: { type: "sawtooth" },
    filter: { type: "lowpass", frequency: 150 },
    envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.3 },
    volume: -8
  }).toDestination();

  // Drums setup
  const kick = new Tone.MembraneSynth({
    pitchDecay: 0.01,
    octaves: 10,
    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 },
    volume: 10
  }).toDestination();

  const snare = new Tone.NoiseSynth({
    noise: { type: "white" },
    envelope: { attack: 0.001, decay: 0.12, sustain: 0 },
    volume: 5
  }).toDestination();

  const hiHatClosed = new Tone.MetalSynth({
    frequency: 8000,
    envelope: { attack: 0.001, decay: 0.03, release: 0.01 },
    harmonicity: 5.1,
    modulationIndex: 32,
    resonance: 4000,
    octaves: 1.5,
    volume: -10
  }).toDestination();

  // Constants
  const measures = 4;
  const beatsPerMeasure = 4;
  const sixteenthNotesPerMeasure = 16;
  const totalSixteenths = measures * sixteenthNotesPerMeasure; // 64 steps

  // Generate drum pattern array
  function generateDrums() {
    const pattern = [];
    for (let i = 0; i < totalSixteenths; i++) {
      const kickHit = (i % 4 === 0 || i % 4 === 2); // Kick on 1 & 3 sixteenth beats of each beat for double kicks
      const snareHit = (i % 16 === 4 || i % 16 === 12); // Snare on beats 2 and 4
      const hiHatHit = true; // constant hi-hat
      pattern.push({ kick: kickHit, snare: snareHit, hiHat: hiHatHit });
    }
    return pattern;
  }

  // Guitar phrase: chord per quarter note (one chord per beat)
  function generateGuitarPhrase() {
    const phrase = [];
    for (let i = 0; i < beatsPerMeasure * measures; i++) {
      if (Math.random() < 0.9) {
        const root = minorPentatonicRoots[Math.floor(Math.random() * minorPentatonicRoots.length)];
        phrase.push(root);
      } else {
        phrase.push(null);
      }
    }
    return phrase;
  }

  // Bass phrase harmonizing guitar phrase
  function generateBassPhrase(guitarPhrase) {
    const phrase = [];
    for (let i = 0; i < guitarPhrase.length; i++) {
      const root = guitarPhrase[i];
      if (!root) {
        phrase.push(null);
      } else {
        const rootMidi = noteToMidi[root];
        const choice = Math.random();
        let midiNote;
        if (choice < 0.6) midiNote = rootMidi - 12; // octave below root
        else if (choice < 0.85) midiNote = rootMidi - 12 + 7; // fifth below
        else midiNote = rootMidi - 24; // two octaves below
        phrase.push(midiToNoteName(midiNote));
      }
    }
    return phrase;
  }

  // Display
  const noteDisplay = document.getElementById("noteDisplay");
  let displayLines = { guitar: "", bass: "", drums: "" };

  function appendPhraseToDisplay(guitarPhrase, bassPhrase, drumsPattern) {
    const measureLength = beatsPerMeasure;
    const phraseMeasures = measures;

    // Guitar & Bass display - per beat
    for (let i = 0; i < guitarPhrase.length; i++) {
      if (i > 0 && i % measureLength === 0) {
        displayLines.guitar += " | ";
        displayLines.bass += " | ";
      }
      displayLines.guitar += guitarPhrase[i] ? guitarPhrase[i] : "-";
      displayLines.bass += bassPhrase[i] ? bassPhrase[i][0] : "-";
    }

    // Drums display - per 16th note
    for (let i = 0; i < drumsPattern.length; i++) {
      if (i > 0 && i % sixteenthNotesPerMeasure === 0) {
        displayLines.drums += " | ";
      }
      const step = drumsPattern[i];
      let d = "";
      if (step.kick) d += "K";
      if (step.snare) d += "S";
      if (step.hiHat) d += "H";
      displayLines.drums += d.padEnd(3, " ");
    }

    noteDisplay.textContent =
      "Guitar  : " + displayLines.guitar + "\n" +
      "Bass    : " + displayLines.bass + "\n" +
      "Drums   : " + displayLines.drums + "\n\n";

    noteDisplay.scrollTop = noteDisplay.scrollHeight;
  }

  // Play functions for single step

  // stepIndex is from 0 to totalSixteenths-1
  function playDrumStep(stepIndex, pattern, time) {
    const step = pattern[stepIndex];
    if (!step) return;
    if (step.kick) kick.triggerAttackRelease("C2", "16n", time);
    if (step.snare) snare.triggerAttackRelease("16n", time + 0.001);
    if (step.hiHat) hiHatClosed.triggerAttackRelease("32n", time + 0.001);
  }

  // Guitar plays once per quarter note (every 4 sixteenths)
  // Calculate which chord to play on current step
  function playGuitarStep(stepIndex, phrase, time) {
    if (stepIndex % 4 === 0) {
      const chordIndex = Math.floor(stepIndex / 4);
      const root = phrase[chordIndex];
      if (root) {
        guitar.triggerAttackRelease(powerChord(root), "8n", time);
      }
    }
  }

  // Bass plays same as guitar, once per quarter note
  function playBassStep(stepIndex, phrase, time) {
    if (stepIndex % 4 === 0) {
      const noteIndex = Math.floor(stepIndex / 4);
      const note = phrase[noteIndex];
      if (note) {
        bass.triggerAttackRelease(note, "8n", time);
      }
    }
  }

  // State vars
  let currentStep = 0;
  let guitarPhrase, bassPhrase, drumsPattern;
  let loop;

  async function startLoop() {
    await Tone.start();
    if (loop) return;

    currentStep = 0;
    displayLines = { guitar: "", bass: "", drums: "" };
    noteDisplay.textContent = "";

    guitarPhrase = generateGuitarPhrase();
    bassPhrase = generateBassPhrase(guitarPhrase);
    drumsPattern = generateDrums();

    appendPhraseToDisplay(guitarPhrase, bassPhrase, drumsPattern);

    // Loop runs every 16th note, each time triggering one step of pattern
    loop = new Tone.Loop((time) => {
      playDrumStep(currentStep, drumsPattern, time);
      playGuitarStep(currentStep, guitarPhrase, time);
      playBassStep(currentStep, bassPhrase, time);

      currentStep++;
      if (currentStep >= totalSixteenths) currentStep = 0; // loop forever
    }, "16n");

    Tone.Transport.start();
    loop.start(0);
  }

  function stopLoop() {
    if (loop) {
      loop.stop();
      loop.cancel();
      loop = null;
    }
    Tone.Transport.stop();
    displayLines = { guitar: "", bass: "", drums: "" };
    noteDisplay.textContent = "";
  }

  document.getElementById("startBtn").onclick = startLoop;
  document.getElementById("stopBtn").onclick = stopLoop;
</script>

</body>
</html>
