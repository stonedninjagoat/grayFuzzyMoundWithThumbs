const track1Notes = [];
const track2Notes = [];
const drumNotes = [];

function padRight(str, length) {
  return str + " ".repeat(Math.max(0, length - str.length));
}

async function playLoop() {
  await Tone.start();
  running = true;
  while (running) {
    const chaosLevel = parseInt(chaosRange.value);

    // Pick notes and durations
    const note1 = currentNotes1[Math.floor(Math.random() * currentNotes1.length)];
    const dur1 = getRandomDuration(chaosLevel);
    const durMs1 = getDurationMs(dur1);

    const note2 = currentNotes2[Math.floor(Math.random() * currentNotes2.length)];
    const dur2 = getRandomDuration(chaosLevel);
    const durMs2 = getDurationMs(dur2);

    // Drum patterns
    const drumSounds = ["CHH", "OHH", "K", "S"];
    const drum = drumSounds[Math.floor(Math.random() * drumSounds.length)];
    const durDrum = getRandomDuration(chaosLevel);
    const durMsDrum = getDurationMs(durDrum);

    // Play notes and drums
    synth1.triggerAttackRelease(note1, dur1);
    synth2.triggerAttackRelease(note2, dur2);
    drumSampler.triggerAttackRelease(drum, durDrum);

    // Jianpu degrees (1 to 7) for melodies
    const midi1 = Tone.Frequency(note1).toMidi() % 12;
    const deg1 = jianpuMap[midi1 % 7] || "?";

    const midi2 = Tone.Frequency(note2).toMidi() % 12;
    const deg2 = jianpuMap[midi2 % 7] || "?";

    // Save played notes and drum
    track1Notes.push(deg1);
    track2Notes.push(deg2);
    drumNotes.push(drum);

    // Compute max length for alignment
    const maxLength = Math.max(track1Notes.length, track2Notes.length, drumNotes.length);

    // Pad arrays with spaces to align length (if needed)
    while (track1Notes.length < maxLength) track1Notes.push(" ");
    while (track2Notes.length < maxLength) track2Notes.push(" ");
    while (drumNotes.length < maxLength) drumNotes.push("   ");

    // Build output lines
    let line1 = "";
    let line2 = "";
    let line3 = "";
    for (let i = 0; i < maxLength; i++) {
      line1 += padRight(track1Notes[i], 3);
      line2 += padRight(track2Notes[i], 3);
      line3 += padRight(drumNotes[i], 3);
    }

    noteDisplay.textContent = line1 + "\n" + line2 + "\n" + line3;

    // Wait shortest duration to keep things roughly in sync (you can tweak this)
    await new Promise(r => setTimeout(r, Math.min(durMs1, durMs2, durMsDrum)));
  }
}
