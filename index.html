<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Hardcore Major7 Jam w/ Drums + Jianpu + Random Durations + Sections</title>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
<style>
  body { background:#121212; color:#eee; font-family: monospace; padding:1rem; }
  #output { white-space: pre-wrap; font-size:1.1rem; max-height: 400px; overflow-y: auto; border: 1px solid #444; padding: 0.8rem; }
  button { font-size:1.2rem; padding:0.6rem 1.4rem; margin-top:1rem; border:none; border-radius:5px; cursor:pointer; background:#333; color:#eee; }
  button:hover { background:#555; }
</style>
</head>
<body>

<h2>Hardcore Major7 Jam w/ Drums + Jianpu + Random Durations + Sections</h2>
<button id="start">Start Jam</button>

<pre id="output">
=== Jam Log ===
</pre>

<script>
const JianpuMap = { 'C': '1', 'D': '2', 'E': '3', 'F': '4', 'G': '5', 'A': '6', 'B': '7' };
const major7Intervals = [0,4,7,11];
const roots = ['C','D','E','F','G','A','B'];

const drumPatterns = {
  hihat: ['open', 'close', 'close', 'open', 'close', 'close', 'close', 'open'],
  kick:  [1,0,0,0,1,0,0,0],
  snare: [0,0,1,0,0,0,1,0]
};

function noteFromRoot(root, interval) {
  const midiMap = { C: 60, D: 62, E: 64, F: 65, G: 67, A: 69, B: 71 };
  let midi = midiMap[root] + interval;
  const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  let note = noteNames[midi % 12];
  if(note.includes('#')) {
    // Convert sharp to flat (simplified)
    let altMidi = midi - 1;
    note = noteNames[altMidi % 12];
  }
  return note[0];
}

function generateMaj7Pairs(root) {
  const chordNotes = major7Intervals.map(i => noteFromRoot(root, i));
  let pairs = [];
  for(let i=0; i<chordNotes.length; i++) {
    for(let j=i+1; j<chordNotes.length; j++) {
      pairs.push([chordNotes[i], chordNotes[j]]);
    }
  }
  pairs.sort(() => Math.random() - 0.5);
  return pairs;
}

function pairsToJianpu(pairs) {
  return pairs.map(pair => pair.map(note => JianpuMap[note]||'?').join(' ')).join('\n');
}

function drumTrack1Jianpu() {
  return drumPatterns.hihat.map(h => h === 'open' ? '◯' : 'x').join('');
}

function drumTrack2Jianpu() {
  let result = '';
  for(let i=0; i<8; i++) {
    if(drumPatterns.kick[i] && drumPatterns.snare[i]) result += '◎';
    else if(drumPatterns.kick[i]) result += '●';
    else if(drumPatterns.snare[i]) result += '○';
    else result += '·';
  }
  return result;
}

const sectionPatterns = [
  ['A','B','A','B'],
  ['A','A','B','B'],
  ['A','B','C','D'],
  ['A','B','C','C']
];

let sectionRoots = {};
function randomizeSectionRoots() {
  sectionRoots = {};
  ['A','B','C','D'].forEach(s => {
    sectionRoots[s] = roots[Math.floor(Math.random()*roots.length)];
  });
}

let currentPattern = [];
let currentSectionIndex = 0;
let measureCount = 0;

function choosePattern() {
  currentPattern = sectionPatterns[Math.floor(Math.random()*sectionPatterns.length)];
  currentSectionIndex = 0;
  randomizeSectionRoots();
}

const guitarSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { type: 'square' },
  envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.1 }
}).toDestination();

const bassSynth = new Tone.MonoSynth({
  oscillator: { type: 'sawtooth' },
  filter: { Q: 2, type: 'lowpass', rolloff: -24 },
  envelope: { attack: 0.01, decay: 0.3, sustain: 0.5, release: 0.3 },
  filterEnvelope: { attack: 0.001, decay: 0.01, sustain: 0.5, release: 0.01, baseFrequency: 200, octaves: 2.6 }
}).toDestination();

const drumKick = new Tone.MembraneSynth({
  pitchDecay: 0.05,
  octaves: 10,
  envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
  volume: -8
}).toDestination();

const drumSnare = new Tone.NoiseSynth({
  noise: { type: 'white' },
  envelope: { attack: 0.001, decay: 0.15, sustain: 0 },
  volume: -12
}).toDestination();

const drumHiHat = new Tone.MetalSynth({
  frequency: 4000,
  envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
  harmonicity: 5.1,
  modulationIndex: 32,
  resonance: 4000,
  octaves: 1.5,
  volume: -15
}).toDestination();

function playBassNote(root, duration) {
  const octave = 2;
  bassSynth.triggerAttackRelease(root + octave, duration);
}

function scheduleDrums(startMeasure) {
  for(let i=0; i<8; i++) {
    let time = `${startMeasure}m + ${i*0.5}n`;
    if(drumPatterns.kick[i]) {
      Tone.Transport.scheduleOnce(() => drumKick.triggerAttackRelease('C2', '8n'), time);
    }
    if(drumPatterns.snare[i]) {
      Tone.Transport.scheduleOnce(() => drumSnare.triggerAttackRelease('16n'), time);
    }
    if(drumPatterns.hihat[i] === 'open') {
      Tone.Transport.scheduleOnce(() => drumHiHat.triggerAttackRelease('16n'), time);
    } else if(drumPatterns.hihat[i] === 'close') {
      Tone.Transport.scheduleOnce(() => drumHiHat.triggerAttackRelease('32n'), time);
    }
  }
}

let guitarPairs = [];
let currentDyadIndex = 0;

function playMeasure(time) {
  if(measureCount % 4 === 0) {
    choosePattern();
  }
  const section = currentPattern[currentSectionIndex];
  const root = sectionRoots[section];
  guitarPairs = generateMaj7Pairs(root);
  currentDyadIndex = 0;

  // Randomize durations slightly for natural feel
  function randDur() {
    const options = ['8n', '8t', '16n', '16t'];
    return options[Math.floor(Math.random()*options.length)];
  }

  // Play bass root at measure start with random duration 8n or 8t
  playBassNote(root, randDur());

  // Play guitar dyads spaced evenly through measure (4 dyads, quarter note each)
  for(let i=0; i<4; i++) {
    let playTime = `+${i * 0.5}n`;
    Tone.Transport.scheduleOnce(() => {
      const dyad = guitarPairs[currentDyadIndex % guitarPairs.length];
      const octave = 4;
      const notesToPlay = dyad.map(n => n + octave);
      guitarSynth.triggerAttackRelease(notesToPlay, randDur());
      currentDyadIndex++;
    }, `${time} + ${i * 0.5}n`);
  }

  scheduleDrums(measureCount);

  // Append new Jianpu output (don't erase old)
  const out = document.getElementById('output');
  out.textContent += 
`---
Measure ${measureCount+1} | Section ${section} | Root: ${root}

Guitar Jianpu:
${pairsToJianpu(guitarPairs)}

Bass Jianpu:
${JianpuMap[root] || '?'}

Drums Track1 (HiHat):
${drumTrack1Jianpu()}

Drums Track2 (Kick/Snare):
${drumTrack2Jianpu()}

`;

  measureCount++;
  currentSectionIndex = (currentSectionIndex + 1) % currentPattern.length;

  // Auto scroll down the output box
  out.scrollTop = out.scrollHeight;
}

document.getElementById('start').onclick = async () => {
  await Tone.start();
  measureCount = 0;
  choosePattern();
  Tone.Transport.bpm.value = 220;
  Tone.Transport.scheduleRepeat(playMeasure, '1m');
  Tone.Transport.start();
  document.getElementById('start').disabled = true;
  document.getElementById('start').textContent = 'Playing...';
};
</script>

</body>
</html>
