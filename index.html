<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Major7 Guitar Dyads + Bass + Drums + Jianpu Output</title>
<script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
<style>
  body { background:#121212; color:#eee; font-family: monospace; padding:1rem; }
  #output { white-space: pre-wrap; font-size:1.2rem; margin-top:1rem; }
  button { font-size:1.2rem; padding:0.6rem 1.4rem; margin-top:1rem; border:none; border-radius:5px; cursor:pointer; background:#333; color:#eee; }
  button:hover { background:#555; }
</style>
</head>
<body>

<h2>Major7 Guitar Dyads + Bass + Drums + Jianpu Output</h2>
<button id="start">Start Jam</button>

<pre id="output">
Guitar Jianpu: -  
Bass Jianpu: -  
Drums Track1 (HiHat): -  
Drums Track2 (Kick/Snare): -
</pre>

<script>
const JianpuMap = { 'C': '1', 'D': '2', 'E': '3', 'F': '4', 'G': '5', 'A': '6', 'B': '7' };
const major7Intervals = [0,4,7,11];
const roots = ['C','D','E','F','G','A','B'];

// Drum patterns: 8 eighth notes per measure
const drumPatterns = {
  hihat: ['open', 'close', 'close', 'open', 'close', 'close', 'close', 'open'],
  kick:  [1,0,0,0,1,0,0,0],
  snare: [0,0,1,0,0,0,1,0]
};

// Convert root + interval to note letter (simplified, no sharps)
function noteFromRoot(root, interval) {
  const midiMap = { C: 60, D: 62, E: 64, F: 65, G: 67, A: 69, B: 71 };
  let midi = midiMap[root] + interval;
  const noteNames = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
  let note = noteNames[midi % 12];
  if(note.includes('#')) {
    // Convert sharps to flats (down one semitone)
    let altMidi = midi - 1;
    note = noteNames[altMidi % 12];
  }
  return note[0];
}

// Generate all unique pairs of notes from Major7 chord
function generateMaj7Pairs(root) {
  const chordNotes = major7Intervals.map(i => noteFromRoot(root, i));
  let pairs = [];
  for(let i=0; i<chordNotes.length; i++) {
    for(let j=i+1; j<chordNotes.length; j++) {
      pairs.push([chordNotes[i], chordNotes[j]]);
    }
  }
  // Shuffle pairs randomly each time called
  pairs.sort(() => Math.random() - 0.5);
  return pairs;
}

// Jianpu output for pairs
function pairsToJianpu(pairs) {
  return pairs.map(pair => pair.map(note => JianpuMap[note]||'?').join(' ')).join('\n');
}

function drumTrack1Jianpu() {
  return drumPatterns.hihat.map(h => h === 'open' ? '◯' : 'x').join('');
}

function drumTrack2Jianpu() {
  let result = '';
  for(let i=0; i<8; i++) {
    if(drumPatterns.kick[i] && drumPatterns.snare[i]) result += '◎';
    else if(drumPatterns.kick[i]) result += '●';
    else if(drumPatterns.snare[i]) result += '○';
    else result += '·';
  }
  return result;
}

const sectionPatterns = [
  ['A','B','A','B'],
  ['A','A','B','B'],
  ['A','B','C','D'],
  ['A','B','C','C']
];

let sectionRoots = {};
function randomizeSectionRoots() {
  sectionRoots = {};
  ['A','B','C','D'].forEach(s => {
    sectionRoots[s] = roots[Math.floor(Math.random()*roots.length)];
  });
}

let currentPattern = [];
let currentSectionIndex = 0;
let measureCount = 0;

function choosePattern() {
  currentPattern = sectionPatterns[Math.floor(Math.random()*sectionPatterns.length)];
  currentSectionIndex = 0;
  randomizeSectionRoots();
}

// Tone.js Synth setup
const guitarSynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { type: 'square' },
  envelope: { attack: 0.01, decay: 0.1, sustain: 0.4, release: 0.1 }
}).toDestination();

const bassSynth = new Tone.MonoSynth({
  oscillator: { type: 'sawtooth' },
  filter: { Q: 2, type: 'lowpass', rolloff: -24 },
  envelope: { attack: 0.01, decay: 0.3, sustain: 0.5, release: 0.3 },
  filterEnvelope: { attack: 0.001, decay: 0.01, sustain: 0.5, release: 0.01, baseFrequency: 200, octaves: 2.6 }
}).toDestination();

const drumKick = new Tone.MembraneSynth({
  pitchDecay: 0.05,
  octaves: 10,
  envelope: { attack: 0.001, decay: 0.2, sustain: 0 },
  volume: -8
}).toDestination();

const drumSnare = new Tone.NoiseSynth({
  noise: { type: 'white' },
  envelope: { attack: 0.001, decay: 0.15, sustain: 0 },
  volume: -12
}).toDestination();

const drumHiHat = new Tone.MetalSynth({
  frequency: 4000,
  envelope: { attack: 0.001, decay: 0.1, release: 0.01 },
  harmonicity: 5.1,
  modulationIndex: 32,
  resonance: 4000,
  octaves: 1.5,
  volume: -15
}).toDestination();

// Play a dyad (two notes) for guitar, in octave 4
function playGuitarDyad(notes) {
  // Map note letters to MIDI note names with octave 4
  const octave = 4;
  const midiNotes = notes.map(n => n + octave);
  guitarSynth.triggerAttackRelease(midiNotes, '8n');
}

// Play bass root note octave 2 or 3 (to sound lower)
function playBassNote(root) {
  const octave = 2;
  const midiNote = root + octave;
  bassSynth.triggerAttackRelease(midiNote, '4n');
}

// Schedule drum pattern (8 eighth notes) on Tone.Transport position (0 to 7)
function scheduleDrums(startMeasure) {
  for(let i=0; i<8; i++) {
    let time = `${startMeasure}m + ${i*0.5}n`;
    if(drumPatterns.kick[i]) {
      Tone.Transport.scheduleOnce(() => drumKick.triggerAttackRelease('C2', '8n'), time);
    }
    if(drumPatterns.snare[i]) {
      Tone.Transport.scheduleOnce(() => drumSnare.triggerAttackRelease('16n'), time);
    }
    if(drumPatterns.hihat[i] === 'open') {
      Tone.Transport.scheduleOnce(() => drumHiHat.triggerAttackRelease('16n'), time);
    } else if(drumPatterns.hihat[i] === 'close') {
      Tone.Transport.scheduleOnce(() => drumHiHat.triggerAttackRelease('32n'), time);
    }
  }
}

let guitarPairs = [];
let currentDyadIndex = 0;

function playMeasure(time) {
  if(measureCount % 4 === 0) {
    choosePattern();
  }
  const section = currentPattern[currentSectionIndex];
  const root = sectionRoots[section];
  guitarPairs = generateMaj7Pairs(root);
  currentDyadIndex = 0;

  // Play bass root at measure start
  playBassNote(root);

  // Schedule guitar dyads every 2 eighth notes (quarter notes) inside measure
  for(let i=0; i<4; i++) {
    let playTime = `+${i * 0.5}n`; // every 0.5 quarter notes = 8th notes
    Tone.Transport.scheduleOnce(() => {
      const dyad = guitarPairs[currentDyadIndex % guitarPairs.length];
      // Convert dyad note letters to note names with octave for synth
      const octave = 4;
      const notesToPlay = dyad.map(n => n + octave);
      guitarSynth.triggerAttackRelease(notesToPlay, '8n');
      currentDyadIndex++;
    }, `${time} + ${i * 0.5}n`);
  }

  // Schedule drums for this measure
  scheduleDrums(measureCount);

  // Update Jianpu output immediately
  document.getElementById('output').textContent = 
`Guitar Jianpu:
${pairsToJianpu(guitarPairs)}

Bass Jianpu:
${JianpuMap[root] || '?'}

Drums Track1 (HiHat):
${drumTrack1Jianpu()}

Drums Track2 (Kick/Snare):
${drumTrack2Jianpu()}`;

  measureCount++;
  currentSectionIndex = (currentSectionIndex + 1) % currentPattern.length;
}

document.getElementById('start').onclick = async () => {
  await Tone.start();
  measureCount = 0;
  choosePattern();
  Tone.Transport.bpm.value = 220; // hardcore speed
  Tone.Transport.scheduleRepeat(playMeasure, '1m');
  Tone.Transport.start();
  document.getElementById('start').disabled = true;
  document.getElementById('start').textContent = 'Playing...';
};
</script>

</body>
</html>
