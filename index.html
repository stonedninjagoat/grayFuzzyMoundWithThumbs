<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Post-Hardcore Jam</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.min.js"></script>
</head>
<body>
  <h2>Post-Hardcore Progressive Jam - Guitar + Bass + Drums + Vocals</h2>
  <button id="startButton">Start Jam</button>
  <script>
    // Wait for user interaction to start Audio context
    document.getElementById('startButton').onclick = async () => {
      await Tone.start();
      startJam();
      document.getElementById('startButton').disabled = true;
      document.getElementById('startButton').innerText = 'Playing...';
    };

    // === Instruments Setup ===

    // Guitar with overdrive effect
    const guitarSynth = new Tone.PolySynth(Tone.Synth, {
      oscillator: { type: "sawtooth" },
      envelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.6 }
    });
    const overdrive = new Tone.Distortion(0.5).toDestination();
    guitarSynth.connect(overdrive);

    // Bass guitar (electric bass style)
    const bassSynth = new Tone.PolySynth(Tone.MonoSynth, {
      oscillator: { type: "square" },
      filter: { Q: 2, type: "lowpass", rolloff: -24 },
      envelope: { attack: 0.01, decay: 0.1, sustain: 0.7, release: 0.8 },
      filterEnvelope: { attack: 0.001, decay: 0.01, sustain: 0.7, release: 0.8, baseFrequency: 200, octaves: 2.6 }
    }).toDestination();

    // Drum kit using Sampler with acoustic drum samples
    const drumKit = new Tone.Players({
      kick: "https://tonejs.github.io/audio/drum-samples/breakbeat/kick.mp3",
      snare: "https://tonejs.github.io/audio/drum-samples/breakbeat/snare.mp3",
      hihat: "https://tonejs.github.io/audio/drum-samples/breakbeat/hihat.mp3"
    }).toDestination();

    // Vocal lead synth (clean sine with some reverb)
    const vocalLead = new Tone.Synth({
      oscillator: { type: "sine" },
      envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.6 }
    });
    const vocalReverb = new Tone.Reverb({ decay: 2, wet: 0.15 }).toDestination();
    vocalLead.connect(vocalReverb);

    // === Musical Data & Helpers ===

    // Post-hardcore common chord roots (letter to note)
    const rootNoteMap = {
      A: "A3",
      B: "B3",
      C: "C4",
      D: "D4",
      E: "E4",
      F: "F4",
      G: "G4"
    };

    // Chord types commonly used (simplified triads + power chords)
    const chordMap = {
      A: [0, 7],            // A5 power chord (root + perfect 5th)
      B: [0, 4, 7],         // B major triad
      C: [0, 3, 7],         // C minor triad
      D: [0, 4, 7],         // D major triad
      E: [0, 7],            // E5 power chord
      F: [0, 3, 7],         // F minor triad
      G: [0, 4, 7]          // G major triad
    };

    // Chord progression sections for variety, like ABAB, AABB, ABCD, etc.
    const progressionPatterns = [
      ['A', 'B', 'A', 'B'],
      ['A', 'A', 'B', 'B'],
      ['A', 'B', 'C', 'D'],
      ['A', 'B', 'C', 'C'],
      ['A', 'B', 'C', 'B'],
      ['A', 'C', 'B', 'D']
    ];

    // Convert note name (e.g. "C4") to MIDI number
    function noteToMidi(note) {
      const noteRegex = /^([A-G])(#|b)?(\d)$/;
      const noteBase = { C:0, D:2, E:4, F:5, G:7, A:9, B:11 };
      const m = note.match(noteRegex);
      if (!m) return null;
      let [_, letter, accidental, octave] = m;
      let midi = noteBase[letter] + 12 * (parseInt(octave) + 1);
      if (accidental === "#") midi += 1;
      else if (accidental === "b") midi -= 1;
      return midi;
    }

    // Convert MIDI number back to note name (simplified)
    function midiToNoteName(midi) {
      const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const octave = Math.floor(midi / 12) - 1;
      const note = notes[midi % 12];
      return note + octave;
    }

    // Play chord on guitar (longer sustain)
    function playChord(chordLetter, time) {
      const root = rootNoteMap[chordLetter];
      if (!root) return;
      const rootMidi = noteToMidi(root);
      const intervals = chordMap[chordLetter] || [0, 7];
      const notes = intervals.map(i => midiToNoteName(rootMidi + i));
      guitarSynth.triggerAttack(notes, time);
      guitarSynth.triggerRelease(time + Tone.Time("2n").toSeconds()); // 2 quarter notes sustain
    }

    // Play bass root + octave notes
    function playBass(chordLetter, time) {
      const root = rootNoteMap[chordLetter];
      if (!root) return;
      const rootMidi = noteToMidi(root);
      const octaveNote = midiToNoteName(rootMidi + 12);
      bassSynth.triggerAttack([root, octaveNote], time);
      bassSynth.triggerRelease(time + Tone.Time("2n").toSeconds());
    }

    // Schedule simple punk drum beat with kick, snare, hihat every measure (4/4)
    function scheduleDrums(startTime) {
      // Kick on 1 and 3
      drumKit.player("kick").start(startTime);
      drumKit.player("kick").start(startTime + Tone.Time("2n").toSeconds());
      // Snare on 2 and 4
      drumKit.player("snare").start(startTime + Tone.Time("4n").toSeconds());
      drumKit.player("snare").start(startTime + Tone.Time("4n").toSeconds() * 3);
      // Hi-hat every 8th note
      for (let i = 0; i < 8; i++) {
        drumKit.player("hihat").start(startTime + i * Tone.Time("8n").toSeconds());
      }
    }

    // Generate a simple vocal melody - notes mostly within pentatonic scale and singable range
    function generateVocalMelody(chords) {
      // Map chord letters to scale degrees for vocal melody (C major pentatonic for demo)
      // This is simplified and can be expanded with better logic
      const scaleNotes = {
        A: ["A4", "C5", "E5"],
        B: ["B4", "D5", "F#5"],
        C: ["C5", "E5", "G5"],
        D: ["D5", "F#5", "A5"],
        E: ["E5", "G#5", "B5"],
        F: ["F5", "A5", "C6"],
        G: ["G4", "B4", "D5"]
      };
      let melody = [];
      for (let c of chords) {
        const choices = scaleNotes[c] || ["C5"];
        const note = choices[Math.floor(Math.random() * choices.length)];
        melody.push(note);
      }
      return melody;
    }

    // Play one measure (4 chords) with guitar, bass, drums, and vocal melody
    function playMeasure(chordSequence, measureIndex, startTime) {
      for (let i = 0; i < chordSequence.length; i++) {
        const chordLetter = chordSequence[i];
        const time = startTime + i * Tone.Time("4n").toSeconds();
        playChord(chordLetter, time);
        playBass(chordLetter, time);
      }
      scheduleDrums(startTime);

      const vocalMelody = generateVocalMelody(chordSequence);
      for (let i = 0; i < vocalMelody.length; i++) {
        const vocalTime = startTime + i * Tone.Time("4n").toSeconds() + 0.05;
        vocalLead.triggerAttackRelease(vocalMelody[i], "8n", vocalTime);
      }
    }

    // Randomly choose section pattern and loop indefinitely
    function startJam() {
      const bpm = 200;
      Tone.Transport.bpm.value = bpm;
      Tone.Transport.start();

      let currentMeasure = 0;

      // Loop every measure length
      Tone.Transport.scheduleRepeat(time => {
        // Every 4 measures, pick a new progression pattern randomly
        if (currentMeasure % 4 === 0) {
          currentPattern = progressionPatterns[Math.floor(Math.random() * progressionPatterns.length)];
        }
        // Play the measure chords from current pattern
        playMeasure(currentPattern, currentMeasure, time);

        currentMeasure++;
      }, "1m"); // 1 measure loop (4 beats)

    }

  </script>
</body>
</html>
